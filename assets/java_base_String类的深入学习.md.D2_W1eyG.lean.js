import{_ as i,o as a,c as t,a2 as n}from"./chunks/framework.BGfUC0LL.js";const d=JSON.parse('{"title":"String类的深入学习","description":"","frontmatter":{},"headers":[],"relativePath":"java/base/String类的深入学习.md","filePath":"java/base/String类的深入学习.md","lastUpdated":1770864474000}'),h={name:"java/base/String类的深入学习.md"};function l(p,s,k,e,r,E){return a(),t("div",null,[...s[0]||(s[0]=[n(`<h1 id="string类的深入学习" tabindex="-1">String类的深入学习 <a class="header-anchor" href="#string类的深入学习" aria-label="Permalink to &quot;String类的深入学习&quot;">​</a></h1><h2 id="string类" tabindex="-1">String类 <a class="header-anchor" href="#string类" aria-label="Permalink to &quot;String类&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    implements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CharSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** The value is used for character storage. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value[];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_1-string类的声明" tabindex="-1">1.String类的声明 <a class="header-anchor" href="#_1-string类的声明" aria-label="Permalink to &quot;1.String类的声明&quot;">​</a></h3><ul><li>String类是final的,不可以被继承</li><li>String类底层是char型数组实现的</li><li>value[] 也是final的,而且是private修饰的,这就保证了String类的对象一旦被初始化就无法更改。</li></ul><blockquote><p>String对象被创建后就无法更改指的是常规方法无法更改,因为String类是由char型数组实现的,而这个数组value也是一个引用,我们可以通过暴力反射setAccessible(true),来修改value数组的内容。</p></blockquote><h3 id="_2-常用构造方法" tabindex="-1">2.常用构造方法 <a class="header-anchor" href="#_2-常用构造方法" aria-label="Permalink to &quot;2.常用构造方法&quot;">​</a></h3><p>1.<code>String str = new String();</code>构造一个空字符串</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>2.<code>String str = new String(String string)</code>根据指定的字符串来构造新的String对象</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String original) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> original.value;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> original.hash;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>3.<code>String str = new String(char[] value)</code>通过指定字符数组来构造新的String对象</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value[]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copyOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, value.length);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当然,还有我们最常用的<code>String str = &quot;123&quot;</code>,不过这种通过<strong>字面量</strong>形式构造对象的方式完全等同于上述的第三种形式,实际上它的实现是:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] chars </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chars);</span></span></code></pre></div><h3 id="_3-关于声明一个字符串是否创建了对象" tabindex="-1">3.关于声明一个字符串是否创建了对象 <a class="header-anchor" href="#_3-关于声明一个字符串是否创建了对象" aria-label="Permalink to &quot;3.关于声明一个字符串是否创建了对象&quot;">​</a></h3><ul><li>由字面量声明的字符串不一定创建了对象</li></ul><p>String a = &quot;123&quot;;是否创建了对象要看字符串常量池中,是否已经有了&quot;123&quot;这个对象,如果有,那么这句代码就没有创建对象,如果没有,那么就在字符串常量池中创建了一个&quot;123&quot;对象.</p><ul><li>通过new出来的字符串一定创建了对象</li></ul><p>String a = new String(&quot;123&quot;),无论字符串常量池是否有&quot;123&quot;这个对象,这句代码都会创建对象,区别就在于创建了一个还是两个.假如常量池中没有,那么就分别在常量池和堆区都分别创建了&quot;123&quot;对象。如果常量池中有该对象,那么就只在堆区中创建一个&quot;123&quot;对象。</p><h2 id="字符串常量池" tabindex="-1">字符串常量池 <a class="header-anchor" href="#字符串常量池" aria-label="Permalink to &quot;字符串常量池&quot;">​</a></h2><h3 id="_1-字符串常量池的设计思想" tabindex="-1">1.字符串常量池的设计思想 <a class="header-anchor" href="#_1-字符串常量池的设计思想" aria-label="Permalink to &quot;1.字符串常量池的设计思想&quot;">​</a></h3><ul><li><p>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能</p></li><li><p>JVM为了提高性能和减少内存开销，为字符串开辟一个字符串常量池，类似于缓存区,创建字符串常量时，首先判断字符串常量池是否存在该字符串.如果存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</p></li><li><p>实现的基础:字符串<strong>不可变</strong></p></li></ul><h3 id="_2-字符串常量池的位置" tabindex="-1">2.字符串常量池的位置 <a class="header-anchor" href="#_2-字符串常量池的位置" aria-label="Permalink to &quot;2.字符串常量池的位置&quot;">​</a></h3><p>字符串常量池在JDK1.6之前是存放在Perm区的(永久代),也就是我们常说的方法区,而在JDK1.7之后,字符串常量池已经被移到了Heap区(堆区)存放,而在JDK1.8,Perm区已经被移除了,取而代之是元空间。</p><blockquote><p>我们常说的方法区,其实是JVM中提出的规范,永久代和方法区的关系,类似我们Java中的类与接口,方法区是一个接口,制定了规范,而永久代是HotSpot虚拟机对这个规范的实现</p></blockquote><p>并且,字符串常量池相较其他常量池有着特殊性:</p><ul><li><p>直接使用字面量声明的String对象，如果在常量池中不存在，那么就会直接存储在字符串常量池中,如果存在,那么就会直接指向字符串常量池中的对象</p></li><li><p>而通过new关键字创建的String对象,如果在常量池中不存在，可以通过native方法<code>intern</code>手动入池。而即使常量池中存在这个字符串,这个方法就不会生效.</p></li><li><p><strong>能否入池，都取决于字符串常量池中是否存在该字符串。</strong></p><ul><li>如果不存在就会入池。</li><li>如果存在，那么通过字面量声明的字符串就会直接从常量池中取值；而intern方法就没有任何效果</li></ul></li></ul><p><strong>很重要的一点：</strong></p><p>​ 由于JDK对于字符串常量池的改动，在JDK1.7和之后的版本，字符串常量池都在堆区中了，而且，<strong>使用intern方法入池的字符串，不会再在字符串常量池中创建一个对象，而是保存调用intern方法的这个字符串的引用。</strong></p><h2 id="stringbuilder和stringbuffer" tabindex="-1">StringBuilder和StringBuffer <a class="header-anchor" href="#stringbuilder和stringbuffer" aria-label="Permalink to &quot;StringBuilder和StringBuffer&quot;">​</a></h2><p>众所周知，在Java中,运算符<code>+</code>在和字符串一起使用时的作用是<code>拼接</code>,而非运算,那么到底是什么原因呢,其实底层就是StringBuffer(JDK1.0)和StringBuilder(JDK1.5之后)实现的。</p><p>看了API就会发现，StringBuilder和StringBuffer都是<strong>可变字符序列</strong>，而且两者的方法是完全一样的，唯一的区别就是线程安全问题，StringBuilder是线程不安全的，而StringBuffer是线程安全的，而StringBuffer始于JDK1.0，StringBuilder始于JDK1.5，也就是说，StringBuilder的出现，就是为了在单线程条件下替换StringBuffer，也就意味着，在不考虑线程安全问题的情况下，我们通常都会使用StringBuilder，因为没有线程问题的影响，StringBuilder的速度更快。</p><p>再说回字符串拼接的问题，</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//&quot;123&quot;</span></span></code></pre></div><p>上面这个代码片段的底层实现,其实是:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a))).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>换言之,字符串拼接,其实是创建了一个新的StringBuilder的对象,来调用append方法进行拼接,拼接完成后再调用toString方法来返回一个新的字符串.</p><p>因此,</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d);</span></span></code></pre></div><p>这个代码片段的结果是HelloWorld,HelloWorld,false。</p><p>原因是StringBuilder的toString方法每次都会返回一个new出来的String对象。源码如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//StringBuilder类重写的toString方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Create a copy, don&#39;t share the array</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="关于string类的面试题" tabindex="-1">关于String类的面试题 <a class="header-anchor" href="#关于string类的面试题" aria-label="Permalink to &quot;关于String类的面试题&quot;">​</a></h2><h3 id="题目1" tabindex="-1">题目1: <a class="header-anchor" href="#题目1" aria-label="Permalink to &quot;题目1:&quot;">​</a></h3><h3 id="string-str-new-string-123-一共创建了几个对象" tabindex="-1">String str = new String（&quot;123&quot;)一共创建了几个对象 <a class="header-anchor" href="#string-str-new-string-123-一共创建了几个对象" aria-label="Permalink to &quot;String str = new String（&quot;123&quot;)一共创建了几个对象&quot;">​</a></h3><p>答:</p><p>1.假如字符串常量池中没有&quot;123&quot;这个字符串,那么这条代码就创建了两个对象,第一个是在字符串常量池中创建了字符串对象&quot;123&quot;,然后在堆区创建了一个字符串对象&quot;123&quot;,接着会把堆区这个&quot;123&quot;的引用地址值赋给在栈区声明的str。</p><p>2.假如字符串常量池中有&quot;123&quot;这个字符串,那么就只创建了一个对象,就是在堆区中创建了对象&quot;123&quot;,然后把地址值赋给str.</p><h3 id="题目2" tabindex="-1">题目2: <a class="header-anchor" href="#题目2" aria-label="Permalink to &quot;题目2:&quot;">​</a></h3><p>引用自:<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noreferrer">深入解析String#intern-美团技术团队</a></p><p><strong>代码片段1:</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s3.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s4 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;11&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s4);</span></span></code></pre></div><p>在JDK1.6中:结果是<code>false false</code></p><p>在JDK1.7中:结果是<code> false true</code></p><p>分析:</p><ul><li><strong>在JDK1.6中:字符串常量池存储于永久代</strong></li></ul><p>String s1 = new String(&quot;1&quot;)首先在字符串常量池中创建了对象&quot;1&quot;,然后在堆区创建对象&quot;1&quot;,s1的引用指向的是堆区的对象;</p><p>s1.intern()方法,会查找字符串常量池中是否有&quot;1&quot;这个对象,结果里面有,所以这个方法没有生效,等于没写.</p><p>String s2 = &quot;1&quot;,因为常量池中已经有&quot;1&quot;这个字符串了,所以s2指向了常量池中&quot;1&quot;</p><p><strong>s1指向堆区,s2指向永久代,显然二者地址不同,结果为false</strong></p><p>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);这句代码在堆区创建了两个匿名&quot;1&quot;对象,拼接后的等于在堆区中创建了字符串&quot;11&quot;对象</p><p>s3.intern()方法将&quot;11&quot;对象保存在了字符串常量池中</p><p>String s4 = &quot;11&quot;,指向的是字符串常量池中&quot;11&quot;对象</p><p><strong>s3指向堆区,s4指向永久代,结果为false</strong></p><ul><li><strong>在JDK1.7中:字符串常量池存储于堆区,且intern方法不会创建对象,而是保存堆区对象的引用</strong></li></ul><p>s1在常量池和堆区分别创建了对象&quot;1&quot;,s1指向的是堆区的&quot;1&quot;对象,s.intern()方法无效,s2指向的是常量池中的&quot;1&quot;对象,s1和s2指向地址不同,所以是false;</p><p>s3在堆区创建了对象&quot;11&quot;,s3.intern()将堆区对象存在常量池中,<strong>但是</strong>!!! 这里的<strong>存</strong>是将堆区中&quot;11&quot;的引用存在了常量池,而非创建对象.</p><p>所以s4指向常量池中的引用,其实就是s3的引用,所以s3==s4为true。</p><p><strong>代码片段2：</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String s4 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;11&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s3.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s4);</span></span></code></pre></div><p>JDK1.6结果:<code>false false</code></p><p>JDK1.7结果:<code>false false</code></p><p>分析:</p><ul><li><strong>在JDK1.6中:字符串常量池存储于永久代</strong></li></ul><p>s1在常量池和堆区分别创建了对象&quot;1&quot;,s1指堆区的对象&quot;1&quot;;</p><p>s2指向的是常量池的对象&quot;1&quot;</p><p>因为常量池中有&quot;1&quot;这个对象,所以s1.intern()无效</p><p><strong>s1,s2二者指向地址不同,所以是false.</strong></p><p>s3在堆区创建了对象&quot;11&quot;</p><p>s4在常量池创建了对象&quot;11&quot;,并指向了常量池中的&quot;11&quot;对象</p><p>常量池中已经有了对象&quot;11&quot;,s3.intern()无效</p><p><strong>s3,s4指向不同,所以false</strong></p><ul><li><strong>在JDK1.7中:字符串常量池存储于堆区,且intern方法不会创建对象,而是保存堆区对象的引用</strong></li></ul><p>s1在常量池和堆区分别创建了对象&quot;1&quot;,s1指堆区的对象&quot;1&quot;;</p><p>s2指向的是常量池的对象&quot;1&quot;</p><p>因为常量池中有&quot;1&quot;这个对象,所以s1.intern()无效</p><p><strong>s1,s2二者指向地址不同,所以是false.</strong></p><p>s3在堆区创建了对象&quot;11&quot;</p><p>s4在常量池创建了对象&quot;11&quot;,并指向了常量池中的&quot;11&quot;对象</p><p>常量池中已经有了对象&quot;11&quot;,s3.intern()无效</p><p><strong>s3,s4指向不同,所以false</strong></p>`,92)])])}const o=i(h,[["render",l]]);export{d as __pageData,o as default};
