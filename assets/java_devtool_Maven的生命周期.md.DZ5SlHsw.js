import{_ as e,c as a,o as l,a2 as n}from"./chunks/framework.CQECOx-R.js";const h=JSON.parse('{"title":"Maven的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"java/devtool/Maven的生命周期.md","filePath":"java/devtool/Maven的生命周期.md","lastUpdated":1746516944000}'),i={name:"java/devtool/Maven的生命周期.md"};function s(d,t,p,r,o,c){return l(),a("div",null,t[0]||(t[0]=[n('<h1 id="maven的生命周期" tabindex="-1">Maven的生命周期 <a class="header-anchor" href="#maven的生命周期" aria-label="Permalink to &quot;Maven的生命周期&quot;">​</a></h1><p>maven共有三个标准生命周期：</p><ul><li><p>clean：项目清理的处理</p></li><li><p>default：项目部署的处理</p></li><li><p>site：站点文件生成的处理</p></li></ul><h2 id="maven的构建生命周期" tabindex="-1">Maven的构建生命周期 <a class="header-anchor" href="#maven的构建生命周期" aria-label="Permalink to &quot;Maven的构建生命周期&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">阶段</th><th style="text-align:left;">处理</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">验证 validate</td><td style="text-align:left;">验证项目</td><td style="text-align:left;">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left;">编译 compile</td><td style="text-align:left;">执行编译</td><td style="text-align:left;">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left;">测试 Test</td><td style="text-align:left;">测试</td><td style="text-align:left;">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left;">包装 package</td><td style="text-align:left;">打包</td><td style="text-align:left;">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td style="text-align:left;">检查 verify</td><td style="text-align:left;">检查</td><td style="text-align:left;">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left;">安装 install</td><td style="text-align:left;">安装</td><td style="text-align:left;">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left;">部署 deploy</td><td style="text-align:left;">部署</td><td style="text-align:left;">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><p>平常用到最多的是mvn clean package或者mvn install，两者都会在target生成最终的jar或war文件，区别在于install命令还会将生成的jar或war包安装至本地仓库。而当需要跨项目引用jar包时，我们需要把自己的jar包上传至maven私服（远程仓库）中，之前还傻傻的直接动手去maven私服手动上传jar包，不过相比于mvn deploy肯定是麻烦很多的，maven的deploy可以很方便的将我们工程中的jar发布至maven私服中方便团队间的jar包共享。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当deploy快照版本时，maven会给快照打上时间戳以区分快照的版本，因为快照可能会频繁变更。maven会以包名是否包含SNAPSHOT来判断是否快照。</p></div><h2 id="clean-生命周期" tabindex="-1">Clean 生命周期 <a class="header-anchor" href="#clean-生命周期" aria-label="Permalink to &quot;Clean 生命周期&quot;">​</a></h2><p>当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li>pre-clean：执行一些需要在clean之前完成的工作</li><li>clean：移除所有上一次构建生成的文件</li><li>post-clean：执行一些需要在clean之后立刻完成的工作</li></ul><p>mvn clean 中的 clean 就是上面的 clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，如果执行 mvn clean 将运行以下两个生命周期阶段：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>pre-clean, clean</span></span></code></pre></div><p>如果我们运行 mvn post-clean ，则运行以下三个生命周期阶段：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>pre-clean, clean, post-clean</span></span></code></pre></div><h2 id="site-生命周期" tabindex="-1">Site 生命周期 <a class="header-anchor" href="#site-生命周期" aria-label="Permalink to &quot;Site 生命周期&quot;">​</a></h2><p>Maven Site 插件一般用来创建新的报告文档、部署站点等。</p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul>',17)]))}const g=e(i,[["render",s]]);export{h as __pageData,g as default};
