import{_ as o,c as e,o as l,a2 as t}from"./chunks/framework.CQECOx-R.js";const b=JSON.parse('{"title":"Java日志发展历史","description":"","frontmatter":{},"headers":[],"relativePath":"java/framework/Java日志发展历史.md","filePath":"java/framework/Java日志发展历史.md","lastUpdated":1746516944000}'),r={name:"java/framework/Java日志发展历史.md"};function i(c,a,p,h,d,n){return l(),e("div",null,a[0]||(a[0]=[t('<h1 id="java日志发展历史" tabindex="-1">Java日志发展历史 <a class="header-anchor" href="#java日志发展历史" aria-label="Permalink to &quot;Java日志发展历史&quot;">​</a></h1><blockquote><p>最近java社区被log4j2的远程代码执行漏洞引爆了，不过还好我们公司的日志主要用的logback，只有少数几个服务用的log4j2，不过还是因为这个加了会班=.=。而java日志有很多乱七八糟的log4j，log4j2，logback，slf4j，jul。。。</p><p><a href="https://www.bilibili.com/video/BV1U44y1E7sE" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1U44y1E7sE</a></p></blockquote><h2 id="日志发展史" tabindex="-1">日志发展史 <a class="header-anchor" href="#日志发展史" aria-label="Permalink to &quot;日志发展史&quot;">​</a></h2><h3 id="阶段一" tabindex="-1">阶段一 <a class="header-anchor" href="#阶段一" aria-label="Permalink to &quot;阶段一&quot;">​</a></h3><blockquote><p>2001年以前，java是没有日志库的，打印日志全靠<code>System.out</code>，<code>System.err</code></p></blockquote><p>缺点：</p><p>1.产生大量的io操作</p><p>2.输出的内容不能保存到文件</p><p>3.只能打印在控制台，打印完就看不到了</p><p>4.无法定制化，且粒度不够细</p><h3 id="阶段二" tabindex="-1">阶段二 <a class="header-anchor" href="#阶段二" aria-label="Permalink to &quot;阶段二&quot;">​</a></h3><blockquote><p>大佬Ceki Gülcü在2001年开发出了日志库Log4j，后来Log4j成为了Apache项目，Ceki大佬也加入了Apache组织</p></blockquote><p>Apache曾经还建议过SUN公司引入Log4j到java标准库中，但被拒绝了</p><h3 id="阶段三" tabindex="-1">阶段三 <a class="header-anchor" href="#阶段三" aria-label="Permalink to &quot;阶段三&quot;">​</a></h3><blockquote><p>2002年2月JDK1.4发布，SUN推出了自己的日志标准库JUL（Java Util Logging），其实是照着log4j抄的，但是没抄好，在JDK1.5之后性能和可用性才有所提升</p></blockquote><p>由于Log4j比JUL好用，并且比较成熟，所以Log4j更具优势</p><h3 id="阶段四" tabindex="-1">阶段四 <a class="header-anchor" href="#阶段四" aria-label="Permalink to &quot;阶段四&quot;">​</a></h3><blockquote><p>2002年8月Apache推出了JCL（Jakarta Commons Logging），也就是日志抽象层，支持运行时动态加载日志组件的实现，也提供了一个默认实现的Simple Log。</p><p>（在ClassLoader中进行查找，如果能找到Log4j就默认使用Log4j的实现，如果没有则使用JUL实现，再没有则使用JCL内部提供的Simple Log实现）</p></blockquote><p>但是JCL有三个缺点：</p><ol><li>效率较低</li><li>容易引发混乱</li><li>使用了自定义ClassLoader的程序中，会引发内存泄露</li></ol><h3 id="阶段五" tabindex="-1">阶段五 <a class="header-anchor" href="#阶段五" aria-label="Permalink to &quot;阶段五&quot;">​</a></h3><blockquote><p>2006年大佬Ceki Gülcü（Log4j）因为一些原因离开了Apache，之后Ceki觉得JCL不好用，自己重新开发了一套新的日志标准接口规范Slf4j（Simple Logging Facade for Java），也可称为日志门面，很明显Slf4j是为了对标JCL，后面也证明了Slf4j比JCL更加优秀</p></blockquote><p>大佬Ceki提供了一系列的桥接包来帮助Slf4j接口与其他日志库建立关系，这种方式称为桥接设置模式。</p><p>代码使用Slf4j接口，就可以实现日志的统一标准化，后续如果想要更换日志的实现，只需要引入Slf4j和相关的桥接包，再引入具体的日志标准库即可。</p><h3 id="阶段六" tabindex="-1">阶段六 <a class="header-anchor" href="#阶段六" aria-label="Permalink to &quot;阶段六&quot;">​</a></h3><blockquote><p>Ceki大佬觉得市场上的日志标准库都是间接实现Slf4j接口，每次都需要配合桥接包，因此在2016年，Ceki大佬基于Slf4j接口开发出了Logback日志标准库作为Slf4j的默认实现，Logback也十分给力，在功能的完整度和性能上超越了所有已有的日志标准库</p></blockquote><h3 id="阶段七" tabindex="-1">阶段七 <a class="header-anchor" href="#阶段七" aria-label="Permalink to &quot;阶段七&quot;">​</a></h3><blockquote><p>2012年，Apache推出新项目Log4j2（不兼容Log4j），Log4j2全面借鉴了Slf4j+Logback，虽然log4j2有明显抄袭嫌疑，但是汲取了logback优秀的设计，还解决了一些问题，性能有了极大提升，官方测试是18倍</p></blockquote><p>Log4j2不仅具有Logback的所有特性，还做了分离设计，分为log4j-api和log4j-core，api是日志接口，core是日志标准库，而且Apache也为Log4j2提供了各种桥接包</p>',29)]))}const k=o(r,[["render",i]]);export{b as __pageData,k as default};
