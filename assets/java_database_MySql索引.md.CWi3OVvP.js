import{_ as i,c as a,o as l,a2 as e}from"./chunks/framework.CQECOx-R.js";const g=JSON.parse('{"title":"MySql索引","description":"","frontmatter":{},"headers":[],"relativePath":"java/database/MySql索引.md","filePath":"java/database/MySql索引.md","lastUpdated":1746516944000}'),h={name:"java/database/MySql索引.md"};function n(t,s,p,k,r,d){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="mysql索引" tabindex="-1">MySql索引 <a class="header-anchor" href="#mysql索引" aria-label="Permalink to &quot;MySql索引&quot;">​</a></h1><p>本篇内容基于MySQL的InnoDB存储引擎。</p><h2 id="索引的概念" tabindex="-1">索引的概念 <a class="header-anchor" href="#索引的概念" aria-label="Permalink to &quot;索引的概念&quot;">​</a></h2><p>索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，==对相关列使用索引是提高查询操作速度的最佳途径==。</p><p>InnoDB存储引擎中的索引都是指BTree索引，MySQL中还有Hash索引,详见官网<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noreferrer">存储引擎索引类型</a></p><p><img src="https://storyxc.com/images/blog//1271254-20201013142145162-80980408.png" alt="12712542020101314214516280980408.png"></p><h2 id="索引的原理" tabindex="-1">索引的原理 <a class="header-anchor" href="#索引的原理" aria-label="Permalink to &quot;索引的原理&quot;">​</a></h2><blockquote><p><strong>内容引用自美团技术团队发表的文章</strong><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noreferrer">MySQL索引原理及慢查询优化</a></p><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><p>数据库的索引结构需要做的事:每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p><p><img src="https://storyxc.com/images/blog//d641ac414176455b97a57b6210b9febb.jpg" alt="b树.jpg"> 如上图，是一颗b+树，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noreferrer">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><h4 id="b-树的查找过程" tabindex="-1">b+树的查找过程 <a class="header-anchor" href="#b-树的查找过程" aria-label="Permalink to &quot;b+树的查找过程&quot;">​</a></h4><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><h4 id="b-树性质" tabindex="-1">b+树性质 <a class="header-anchor" href="#b-树性质" aria-label="Permalink to &quot;b+树性质&quot;">​</a></h4><p>1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p><p>2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p></blockquote><h2 id="索引的类别" tabindex="-1">索引的类别 <a class="header-anchor" href="#索引的类别" aria-label="Permalink to &quot;索引的类别&quot;">​</a></h2><h3 id="_1-primary-key-主键索引" tabindex="-1">1.Primary Key(主键索引) <a class="header-anchor" href="#_1-primary-key-主键索引" aria-label="Permalink to &quot;1.Primary Key(主键索引)&quot;">​</a></h3><p>主键索引是一种特殊的唯一索引，这个时候需要一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p><blockquote><p>InnoDB存储引擎的表，如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。</p><p>在其他存储引擎或其他数据库中主键索引不一定就是聚集索引</p></blockquote><h3 id="_2-unique-唯一索引" tabindex="-1">2.Unique（唯一索引） <a class="header-anchor" href="#_2-unique-唯一索引" aria-label="Permalink to &quot;2.Unique（唯一索引）&quot;">​</a></h3><p>唯一索引列的值必须是唯一的，但允许有空值,如果是组合索引，则列值的组合必须是唯一的。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> UNIQUE index</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 索引名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名(列名)</span></span></code></pre></div><h3 id="_3-key-普通索引" tabindex="-1">3.Key（普通索引） <a class="header-anchor" href="#_3-key-普通索引" aria-label="Permalink to &quot;3.Key（普通索引）&quot;">​</a></h3><p>MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 索引名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名(列名)</span></span></code></pre></div><h3 id="_4-组合索引" tabindex="-1">4.组合索引 <a class="header-anchor" href="#_4-组合索引" aria-label="Permalink to &quot;4.组合索引&quot;">​</a></h3><p>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀原则</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 索引名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名(列名,列名...)</span></span></code></pre></div><h3 id="_5-全文索引" tabindex="-1">5.全文索引 <a class="header-anchor" href="#_5-全文索引" aria-label="Permalink to &quot;5.全文索引&quot;">​</a></h3><p>全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建</p><h2 id="索引的基本语法" tabindex="-1">索引的基本语法 <a class="header-anchor" href="#索引的基本语法" aria-label="Permalink to &quot;索引的基本语法&quot;">​</a></h2><ul><li>创建</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mytable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [UNIQUE]  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INDEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [indexName] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名(列名)</span></span></code></pre></div><ul><li>删除</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DROP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [indexName] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名;</span></span></code></pre></div><ul><li>查看</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SHOW </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INDEX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名</span></span></code></pre></div><ul><li>alter命令</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 有四种方式来添加数据表的索引：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> UNIQUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index_name (column_list): 添加普通索引，索引值可出现多次。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FULLTEXT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index_name (column_list):该语句指定了索引为 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FULLTEXT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ，用于全文索引。</span></span></code></pre></div><h2 id="索引的使用场景" tabindex="-1">索引的使用场景 <a class="header-anchor" href="#索引的使用场景" aria-label="Permalink to &quot;索引的使用场景&quot;">​</a></h2><h3 id="_1-适合使用索引" tabindex="-1">1.适合使用索引 <a class="header-anchor" href="#_1-适合使用索引" aria-label="Permalink to &quot;1.适合使用索引&quot;">​</a></h3><ul><li>频繁作为查询条件的字段</li><li>多表查询中与其他表进行关联的字段,外键关系建立索引</li><li>单列/组合索引的选择,在高并发的场景下适合建立组合索引</li><li>查询中常用于排序的字段</li><li>查询中常用于分组或统计的字段</li></ul><h3 id="_2-不适合使用索引" tabindex="-1">2.不适合使用索引 <a class="header-anchor" href="#_2-不适合使用索引" aria-label="Permalink to &quot;2.不适合使用索引&quot;">​</a></h3><ul><li><p>频繁更新的字段</p></li><li><p>where条件中用不到的字段</p></li><li><p>表记录很少</p></li><li><p>重复记录非常多的表</p></li><li><p>数据区分不明显的字段,例如性别栏位</p></li></ul><h2 id="索引有效场景" tabindex="-1">索引有效场景 <a class="header-anchor" href="#索引有效场景" aria-label="Permalink to &quot;索引有效场景&quot;">​</a></h2><ul><li><p>全值匹配的查询,例如根据订单id查询select * from t_order where order_id = &#39;9999676623&#39;</p></li><li><p>匹配范围值的查询,例如 where id &gt; &#39;123456&#39;</p></li><li><p>最左匹配原则,如user表的username pwd创建了组合索引那么以下几种都可以命中索引</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zhangsan&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pwd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;axsedf1sd&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pwd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;axsedf1sd&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zhangsan&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zhangsan&#39;</span></span></code></pre></div><p>而</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pwd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;axsedf1sd&#39;</span></span></code></pre></div><p>不能命中索引</p></li><li><p>非前导模糊查询, 例如 where name like &#39;xiaoming%&#39;</p></li></ul><h3 id="索引失效场景" tabindex="-1">索引失效场景 <a class="header-anchor" href="#索引失效场景" aria-label="Permalink to &quot;索引失效场景&quot;">​</a></h3><ul><li>负向查询会使索引失效,例如 id not in (1,2,3)</li><li>在索引字段进行运算会使索引失效,例如计算,函数,类型转换</li><li>!=或者&lt;&gt;会使索引失效</li><li>is not null无法使用索引,但是is null可以</li><li>前导模糊查询会使索引失效,例如 name like &#39;%xiaoming&#39;,但是非前导可以</li><li>字符串不加单引号会使索引失效</li><li>使用组合索引时不遵循最左匹配原则会使索引失效</li></ul>`,41)]))}const E=i(h,[["render",n]]);export{g as __pageData,E as default};
