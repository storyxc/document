import{_ as s,c as a,o as l,a2 as e}from"./chunks/framework.CQECOx-R.js";const c=JSON.parse('{"title":"Node.js","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/base/Nodejs.md","filePath":"frontend/base/Nodejs.md","lastUpdated":1746516944000}'),n={name:"frontend/base/Nodejs.md"};function t(h,i,p,o,d,r){return l(),a("div",null,i[0]||(i[0]=[e(`<h1 id="node-js" tabindex="-1">Node.js <a class="header-anchor" href="#node-js" aria-label="Permalink to &quot;Node.js&quot;">​</a></h1><h2 id="node-js简介" tabindex="-1">Node.js简介 <a class="header-anchor" href="#node-js简介" aria-label="Permalink to &quot;Node.js简介&quot;">​</a></h2><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。</p><blockquote><p>浏览器是js的前端运行环境</p><p>Node.js是js的后端运行环境</p></blockquote><h3 id="node-js中的javascript运行环境" tabindex="-1">Node.js中的JavaScript运行环境 <a class="header-anchor" href="#node-js中的javascript运行环境" aria-label="Permalink to &quot;Node.js中的JavaScript运行环境&quot;">​</a></h3><ul><li>V8引擎</li><li>内置API <ul><li>fs、path、http、JS、querystring。。。</li></ul></li></ul><h3 id="node-js可以做什么" tabindex="-1">Node.js可以做什么 <a class="header-anchor" href="#node-js可以做什么" aria-label="Permalink to &quot;Node.js可以做什么&quot;">​</a></h3><ul><li>基于Express可以构建Web应用</li><li>基于Electron可以构建跨平台桌面应用</li><li>基于restify可以构建API接口项目</li><li>读写和操作数据库、创建实用的命令行工具辅助开发。。</li></ul><h2 id="基础模块" tabindex="-1">基础模块 <a class="header-anchor" href="#基础模块" aria-label="Permalink to &quot;基础模块&quot;">​</a></h2><h3 id="fs模块" tabindex="-1">fs模块 <a class="header-anchor" href="#fs模块" aria-label="Permalink to &quot;fs模块&quot;">​</a></h3><ul><li>fs.readFile() <ul><li>fs.readFile(path[, options], callback)</li></ul></li><li>fs.writeFile() <ul><li>fs.writeFile(file,data[,options], callback)</li></ul></li><li>动态拼接路径问题：<code>__dirname</code>替代当前文件所处目录 <ul><li><code>__dirname + &#39;/file/1.txt&#39;</code></li></ul></li></ul><h3 id="path模块" tabindex="-1">path模块 <a class="header-anchor" href="#path模块" aria-label="Permalink to &quot;path模块&quot;">​</a></h3><ul><li>path.join()</li><li>path.basename()</li></ul><h3 id="http模块" tabindex="-1">http模块 <a class="header-anchor" href="#http模块" aria-label="Permalink to &quot;http模块&quot;">​</a></h3><h4 id="创建基本的web服务器" tabindex="-1">创建基本的web服务器 <a class="header-anchor" href="#创建基本的web服务器" aria-label="Permalink to &quot;创建基本的web服务器&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> http</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> http.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;request&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;visit&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;text/html; charset=utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;111&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http server running at http://127.0.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ul><li>req <ul><li>url：请求url</li><li>method：请求方法</li></ul></li><li>res <ul><li>end()：发送响应</li></ul></li></ul><h2 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h2><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，对于整个系统来说，模块是可组合、分解和更换的单元。</p><p>模块化优势：</p><ul><li>提高复用性</li><li>提高可维护性</li><li>可以实现按需加载</li></ul><h3 id="node-js模块分类" tabindex="-1">Node.js模块分类 <a class="header-anchor" href="#node-js模块分类" aria-label="Permalink to &quot;Node.js模块分类&quot;">​</a></h3><ul><li>内置模块</li><li>自定义模块</li><li>第三方模块</li></ul><h3 id="加载模块" tabindex="-1">加载模块 <a class="header-anchor" href="#加载模块" aria-label="Permalink to &quot;加载模块&quot;">​</a></h3><ul><li><code>const moduleName = require(&#39;moduleName&#39;)</code></li></ul><blockquote><p>使用require加载模块时会执行被加载模块的代码</p><p>使用自定义模块可以省略<code>.js</code></p></blockquote><h3 id="模块作用域" tabindex="-1">模块作用域 <a class="header-anchor" href="#模块作用域" aria-label="Permalink to &quot;模块作用域&quot;">​</a></h3><p>在自定义模块中定义的变量、方法等成员只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。</p><p>好处：防止全局变量污染</p><h4 id="向外共享模块作用域中的成员" tabindex="-1">向外共享模块作用域中的成员 <a class="header-anchor" href="#向外共享模块作用域中的成员" aria-label="Permalink to &quot;向外共享模块作用域中的成员&quot;">​</a></h4><ul><li><p>module对象：在每个.js自定义模块中都有一个module对象，里面存储了和当前模块有关的信息</p><ul><li><code>console.log(module)</code></li></ul></li><li><p><code>module.exports</code>：可以使用此对象将模块内的成员共享出去供外部使用，<strong>外界使用<code>require()</code>导入自定义模块时，得到的就是module.exports所指向的对象</strong></p><ul><li><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;test&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li></ul><h4 id="exports对象" tabindex="-1">exports对象 <a class="header-anchor" href="#exports对象" aria-label="Permalink to &quot;exports对象&quot;">​</a></h4><p><code>exports</code>对象是<code>module.exports</code>的简化写法，两者指向同一个对象</p><h3 id="模块化规范" tabindex="-1">模块化规范 <a class="header-anchor" href="#模块化规范" aria-label="Permalink to &quot;模块化规范&quot;">​</a></h3><p>Node.js遵循Common.js的模块化规范</p><p>CommonJS规定</p><ul><li>每个模块内部，module代表当前模块</li><li>module变量是一个对象，它的exports属性是对外的接口</li><li>加载某个模块，其实是加载该模块的module.exports属性。require()方法用于加载模块</li></ul><h2 id="npm和包" tabindex="-1">npm和包 <a class="header-anchor" href="#npm和包" aria-label="Permalink to &quot;npm和包&quot;">​</a></h2><p>npm是Node.js的包管理工具</p><ul><li><p><code>npm install</code></p></li><li><p><code>npm uninstall</code></p></li><li><p><code>npm install package</code></p></li><li><p><code>npm i package</code></p></li><li><p><code>npm i package@version</code></p></li></ul><p>包版本的语义化规范</p><ul><li><p>点分十进制，总共三位数字，例如2.14.0</p></li><li><p>第一位数：大版本</p></li><li><p>第二位数：功能版本</p></li><li><p>第三位数：bug修复版本</p></li><li><p>版本号提升规则：前面版本增长，后面版本号归零</p></li></ul><h3 id="安装包后多出来的文件" tabindex="-1">安装包后多出来的文件 <a class="header-anchor" href="#安装包后多出来的文件" aria-label="Permalink to &quot;安装包后多出来的文件&quot;">​</a></h3><ul><li>node_modules: 存放所有已安装到项目中的包</li><li>package-lock.json：记录node_modules目录下每一个包的下载信息，例如包的名字、版本号、下载地址等</li></ul><h3 id="包管理配置文件" tabindex="-1">包管理配置文件 <a class="header-anchor" href="#包管理配置文件" aria-label="Permalink to &quot;包管理配置文件&quot;">​</a></h3><p>npm规定，项目根目录必须提供<code>package.json</code>的包管理配置文件。用来记录与项目有关的配置信息，例如：</p><ul><li>项目的名称、版本号、描述</li><li>项目中用到了哪些包</li><li>哪些包在开发期间会用到</li><li>哪些包在开发和部署时都会用到</li></ul><p>npm创建package.json命令：<code>npm init -y</code></p><blockquote><p>运行npm install时，npm会自动把包名、版本记录到package.json中</p></blockquote><h3 id="dependencies节点" tabindex="-1">dependencies节点 <a class="header-anchor" href="#dependencies节点" aria-label="Permalink to &quot;dependencies节点&quot;">​</a></h3><p><code>package.json</code>中有一个dependencies节点专门记录<code>npm install</code>安装了哪些包</p><h3 id="devdependencies节点" tabindex="-1">devDependencies节点 <a class="header-anchor" href="#devdependencies节点" aria-label="Permalink to &quot;devDependencies节点&quot;">​</a></h3><p>记录只在开发阶段使用、上线不会用到的包</p><ul><li>安装到dev节点中：<code>npm i packageName -D</code> / <code>npm install packageName --save-dev</code></li></ul><h3 id="修改镜像" tabindex="-1">修改镜像 <a class="header-anchor" href="#修改镜像" aria-label="Permalink to &quot;修改镜像&quot;">​</a></h3><ul><li><p><code>npm config get registry</code></p></li><li><p><code>npm config set registry=https://registry.npm.taobao.org/</code></p></li><li><p>nrm工具切换镜像源</p><ul><li><code>npm i nrm -g</code></li><li><code>nrm ls</code></li><li><code>nrm use taobao</code></li></ul></li></ul><h3 id="包分类" tabindex="-1">包分类 <a class="header-anchor" href="#包分类" aria-label="Permalink to &quot;包分类&quot;">​</a></h3><ul><li>项目包：被安装到node_modules的都是项目包 <ul><li>开发依赖包</li><li>核心依赖包</li></ul></li><li>全局包：执行npm install时指定-g参数则会安装为全局包 <ul><li>一般为工具性质的包</li><li>npm install package -g</li><li>npm uninstall package -g</li></ul></li></ul><blockquote><p>i5ting_toc: md转换为html工具</p><p>i5ting_toc -f md -o</p></blockquote><h3 id="包结构" tabindex="-1">包结构 <a class="header-anchor" href="#包结构" aria-label="Permalink to &quot;包结构&quot;">​</a></h3><p>规范的包结构必须符合：</p><ul><li>包必须单独目录</li><li>根目录必须包含package.json</li><li>package.json必须包含name、version、main三个属性，对应包名、版本号、包的入口</li></ul><h3 id="模块的加载机制" tabindex="-1">模块的加载机制 <a class="header-anchor" href="#模块的加载机制" aria-label="Permalink to &quot;模块的加载机制&quot;">​</a></h3><ul><li>优先从缓存中加载：模块在第一次被加载后会被缓存，意味着多次调用require()不会导致模块的代码被多次执行</li><li>内置模块的加载优先级最高</li><li>require()加载自定义模块必需指定<code>./</code>或<code>../</code>开头的路径标识符，否则会被当作内置模块或第三方模块，同时如果导入时省略了扩展名，Node.js会按顺序尝试加载以下文件： <ul><li>按确切文件名加载</li><li>补全.js加载</li><li>补全.json加载</li><li>补全.node记载</li><li>加载失败，报错</li></ul></li><li>如果required()的标识符不是内置模块也不是<code>./</code>开头的路径标识符会被当作第三方模块，会从/node_modules中加载第三方模块 <ul><li>如果没有找到，就移动到上一层进行加载，直到文件系统根目录，找不到报错</li></ul></li><li>目录作为模块标识符的加载顺序 <ul><li>在目录中找package.json的main属性做为require的加载入口</li><li>然后找根目录的index.js</li><li>都找不到报错</li></ul></li></ul>`,64)]))}const u=s(n,[["render",t]]);export{c as __pageData,u as default};
