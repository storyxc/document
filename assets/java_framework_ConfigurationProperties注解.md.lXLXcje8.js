import{_ as o,o as r,c as i,a2 as t}from"./chunks/framework.BGfUC0LL.js";const u=JSON.parse('{"title":"ConfigurationProperties注解","description":"","frontmatter":{},"headers":[],"relativePath":"java/framework/ConfigurationProperties注解.md","filePath":"java/framework/ConfigurationProperties注解.md","lastUpdated":1770864474000}'),a={name:"java/framework/ConfigurationProperties注解.md"};function n(s,e,c,l,p,d){return r(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="configurationproperties注解" tabindex="-1">ConfigurationProperties注解 <a class="header-anchor" href="#configurationproperties注解" aria-label="Permalink to &quot;ConfigurationProperties注解&quot;">​</a></h1><p>@ConfigurationProperties注解可以从外部获取配置信息，并将其绑定到JavaBean中。</p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>SpringBoot可以让配置信息外部化，支持的配置有多种，最常见的<code>.properties</code>、<code>.yaml</code>文件，启动时命令行参数<code>--xxx</code>、系统环境变量、Java系统属性(System.getProperties())...</p><p>@ConfigurationProperties注解的功能由ConfigurationPropertiesBindingPostProcessor这个后置处理器实现，spring容器中的<code>enviroment.propertySources</code>记录着外部的属性值，properties后置处理器会从中找到匹配的值绑定到JavaBean中。</p><p>属性的绑定是会被覆盖的，排序靠后的会覆盖靠前的，即越靠后的优先级越高。（os环境变量可以覆盖application.properties,java系统属性可以覆盖系统环境变量，命令行参数可以覆盖java系统属性...)</p><p>这些配置的方式和可以参照spring boot官方文档：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config" target="_blank" rel="noreferrer">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config</a></p><h2 id="_2-externalized-configuration" tabindex="-1">2. Externalized Configuration <a class="header-anchor" href="#_2-externalized-configuration" aria-label="Permalink to &quot;2. Externalized Configuration&quot;">​</a></h2><p>Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use a variety of external configuration sources, include Java properties files, YAML files, environment variables, and command-line arguments.</p><p>Property values can be injected directly into your beans by using the <code>@Value</code> annotation, accessed through Spring’s <code>Environment</code> abstraction, or be <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties" target="_blank" rel="noreferrer">bound to structured objects</a> through <code>@ConfigurationProperties</code>.</p><p>Spring Boot uses a very particular <code>PropertySource</code> order that is designed to allow sensible overriding of values. Properties are considered in the following order (with values from lower items overriding earlier ones):</p><ol><li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.21/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noreferrer"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</li><li>Config data (such as <code>application.properties</code> files).</li><li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li><li>OS environment variables.</li><li>Java System properties (<code>System.getProperties()</code>).</li><li>JNDI attributes from <code>java:comp/env</code>.</li><li><code>ServletContext</code> init parameters.</li><li><code>ServletConfig</code> init parameters.</li><li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li><li>Command line arguments.</li><li><code>properties</code> attribute on your tests. Available on <a href="https://docs.spring.io/spring-boot/docs/2.7.1/api/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noreferrer"><code>@SpringBootTest</code></a> and the <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests" target="_blank" rel="noreferrer">test annotations for testing a particular slice of your application</a>.</li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.21/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noreferrer"><code>@TestPropertySource</code></a> annotations on your tests.</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings" target="_blank" rel="noreferrer">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</li></ol><p>Config data files are considered in the following order:</p><ol><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files" target="_blank" rel="noreferrer">Application properties</a> packaged inside your jar (<code>application.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific" target="_blank" rel="noreferrer">Profile-specific application properties</a> packaged inside your jar (<code>application-{profile}.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files" target="_blank" rel="noreferrer">Application properties</a> outside of your packaged jar (<code>application.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific" target="_blank" rel="noreferrer">Profile-specific application properties</a> outside of your packaged jar (<code>application-{profile}.properties</code> and YAML variants).</li></ol></blockquote><h3 id="系统环境变量的方式" tabindex="-1">系统环境变量的方式 <a class="header-anchor" href="#系统环境变量的方式" aria-label="Permalink to &quot;系统环境变量的方式&quot;">​</a></h3><p>这里通过系统环境变量的绑定方式大致记录下，因为java应用的docker镜像通常使用这种方式，例如docker启动指令里加上<code>-e xxx=xxx</code>，就是在指定docker容器的系统环境变量。比较常见的<code>-e JAVA_OPTS=xxx</code> ,因为java应用的镜像通常entrypoint都是<code>sh -c java $JAVA_OPTS xxx.jar</code>。</p><p>上文中<code>enviroment.propertySources</code>会读取外部的配置，系统环境变量是通过<code>System.getenv()</code>获取的，通过docker指令给镜像添加了系统环境变量后，就会通过这种方式绑定到java应用的配置类中。</p><h3 id="但是" tabindex="-1">但是 <a class="header-anchor" href="#但是" aria-label="Permalink to &quot;但是&quot;">​</a></h3><p>通过docker指令配置系统环境变量的方式，参数的命名需要做对应的调整，例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ConfigurationProperties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prefix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果是通过<code>.properties</code>文件来配置那么文件中应该是<code>user.name=xxx</code>,如果是通过linux系统环境变量的方式，则环境变量中应该是<code>USER_NAME=xxx</code>.这是因为不同操作系统对环境变量的命名规则都有严格的要求，spring boot的宽松绑定规则要尽可能兼容不同系统的限制.</p><p>linux shell变量的命名规则：可以<code>a-zA-Z0-9</code>，可以下划线<code>_</code>,按照惯例，变量名都是大写的。所以，通过环境变量读取java配置时，应该遵循的原则</p><ul><li><p>将<code>.</code>替换为<code>_</code></p></li><li><p>删除所有破折号<code>-</code></p></li><li><p>变量名转为大写</p></li></ul><p>例：<code>spring.main.log-startup-info</code> -&gt; <code>SPRING_MAIN_LOGSTARTUPINFO</code></p><blockquote><h5 id="binding-from-environment-variables" tabindex="-1">Binding from Environment Variables <a class="header-anchor" href="#binding-from-environment-variables" aria-label="Permalink to &quot;Binding from Environment Variables&quot;">​</a></h5><p>Most operating systems impose strict rules around the names that can be used for environment variables. For example, Linux shell variables can contain only letters (<code>a</code> to <code>z</code> or <code>A</code> to <code>Z</code>), numbers (<code>0</code> to <code>9</code>) or the underscore character (<code>_</code>). By convention, Unix shell variables will also have their names in UPPERCASE.</p><p>Spring Boot’s relaxed binding rules are, as much as possible, designed to be compatible with these naming restrictions.</p><p>To convert a property name in the canonical-form to an environment variable name you can follow these rules:</p><ul><li>Replace dots (<code>.</code>) with underscores (<code>_</code>).</li><li>Remove any dashes (<code>-</code>).</li><li>Convert to uppercase.</li></ul><p>For example, the configuration property <code>spring.main.log-startup-info</code> would be an environment variable named <code>SPRING_MAIN_LOGSTARTUPINFO</code>.</p><p>Environment variables can also be used when binding to object lists. To bind to a <code>List</code>, the element number should be surrounded with underscores in the variable name.</p><p>For example, the configuration property <code>my.service[0].other</code> would use an environment variable named <code>MY_SERVICE_0_OTHER</code>.</p></blockquote>`,19)])])}const g=o(a,[["render",n]]);export{u as __pageData,g as default};
